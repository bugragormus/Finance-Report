"""
data_preview.py - Veri √∂nizleme ve g√∂r√ºnt√ºleme i≈ülemlerini y√∂netir.

Bu mod√ºl, veri √ßer√ßevelerinin g√∂r√ºnt√ºlenmesi, √∂zetlenmesi ve
√ße≈üitli formatlarda dƒ±≈üa aktarƒ±lmasƒ± i√ßin fonksiyonlar i√ßerir.

Fonksiyonlar:
    - show_filtered_data: DataFrame'i g√∂sterir ve Excel √ßƒ±ktƒ±sƒ± verir
    - show_grouped_summary: Gruplandƒ±rƒ±lmƒ±≈ü veri √∂zetini g√∂sterir
    - calculate_group_totals: Grup toplamlarƒ±nƒ± hesaplar
    - show_column_totals: S√ºtun toplamlarƒ±nƒ± g√∂sterir

√ñzellikler:
    - Sayfalama desteƒüi
    - Stil uygulama
    - Sabit s√ºtun desteƒüi
    - Excel dƒ±≈üa aktarƒ±m
    - Hata y√∂netimi

Kullanƒ±m:
    from utils.data_preview import show_filtered_data
    
    excel_buffer = show_filtered_data(
        df,
        filename="rapor.xlsx",
        style_func=style_warning_rows,
        title="Filtrelenmi≈ü Veri"
    )
"""

import streamlit as st
import pandas as pd
from io import BytesIO
from typing import Optional, List, Callable, Union
from utils.error_handler import handle_error, display_friendly_error


@handle_error
def show_filtered_data(
    df: pd.DataFrame, 
    filename: str = "filtrelenmis_rapor.xlsx", 
    style_func: Optional[Callable] = None, 
    title: Optional[str] = None,
    sticky_column: Optional[Union[str, int]] = None,
    page_size: int = 1000
) -> BytesIO:
    """
    DataFrame'i g√∂sterir, istenirse stil uygular, Excel √ßƒ±ktƒ±sƒ± verir.
    
    Bu fonksiyon:
    1. Veri √ßer√ßevesini sayfalar
    2. Stil uygulama se√ßeneƒüi sunar
    3. S√ºtun yapƒ±landƒ±rmasƒ±nƒ± ayarlar
    4. Sabit s√ºtun desteƒüi saƒülar
    5. Excel √ßƒ±ktƒ±sƒ± olu≈üturur
    
    Parameters:
        df (DataFrame): G√∂r√ºnt√ºlenecek veri √ßer√ßevesi
        filename (str): ƒ∞ndirme i√ßin dosya adƒ±
        style_func (Callable, optional): Veri √ßer√ßevesine uygulanacak stil fonksiyonu
        title (str, optional): G√∂r√ºnt√ºleme ba≈ülƒ±ƒüƒ±
        sticky_column (Union[str, int], optional): Sabit kalacak s√ºtun adƒ± veya pozisyonu
        page_size (int): Sayfa ba≈üƒ±na g√∂sterilecek satƒ±r sayƒ±sƒ±
        
    Returns:
        BytesIO: Excel dosyasƒ± buffer'ƒ±
        
    Hata durumunda:
    - Hata loglanƒ±r
    - Kullanƒ±cƒ±ya hata mesajƒ± g√∂sterilir
    - Bo≈ü buffer d√∂nd√ºr√ºl√ºr
    
    √ñrnek:
        >>> df = pd.DataFrame({
        ...     "Masraf Yeri": ["A", "B", "C"],
        ...     "B√ºt√ße": [1000, 2000, 3000]
        ... })
        >>> buffer = show_filtered_data(
        ...     df,
        ...     filename="rapor.xlsx",
        ...     style_func=style_warning_rows,
        ...     sticky_column="Masraf Yeri"
        ... )
    """
    if title:
        st.markdown(title)
    
    # Sabit s√ºtun belirleme
    column_to_stick = None
    if sticky_column is not None:
        if isinstance(sticky_column, str) and sticky_column in df.columns:
            column_to_stick = sticky_column
        elif isinstance(sticky_column, int) and 0 <= sticky_column < len(df.columns):
            column_to_stick = df.columns[sticky_column]
    
    # Stil uygulama se√ßeneƒüi
    apply_style = False
    if style_func and len(df) > page_size:
        apply_style = st.checkbox("‚ö†Ô∏è Stil Uygula (Performansƒ± Etkileyebilir)", value=False)
    
    # Sayfalama
    total_pages = (len(df) + page_size - 1) // page_size
    if total_pages > 1:
        page = st.number_input("üìÑ Sayfa", min_value=1, max_value=total_pages, value=1)
        start_idx = (page - 1) * page_size
        end_idx = min(start_idx + page_size, len(df))
        display_df = df.iloc[start_idx:end_idx]
    else:
        display_df = df
    
    # S√ºtun yapƒ±landƒ±rmasƒ±
    column_config = {}
    for col in display_df.columns:
        if pd.api.types.is_numeric_dtype(display_df[col]):
            column_config[col] = st.column_config.NumberColumn(
                col,
                format="%.2f",
                help=f"{col} deƒüerleri"
            )
        else:
            column_config[col] = st.column_config.TextColumn(
                col,
                help=f"{col} deƒüerleri"
            )
    
    # Sabit s√ºtun yapƒ±landƒ±rmasƒ±
    if column_to_stick:
        column_config[column_to_stick] = st.column_config.Column(
            column_to_stick,
            width="medium",
            help="Bu s√ºtun sabit kalacak",
            pinned=True
        )
    
    # Benzersiz anahtar olu≈ütur
    unique_key = f"data_editor_{filename}_{page if total_pages > 1 else 1}"
    
    # Stil fonksiyonu varsa ve se√ßilmi≈üse uygula
    if style_func and apply_style:
        styled_df = style_func(display_df.copy())
        # Stil uygulanmƒ±≈ü DataFrame'i g√∂ster
        st.data_editor(
            styled_df,
            column_config=column_config,
            use_container_width=True,
            disabled=True,  # D√ºzenleme devre dƒ±≈üƒ±
            #hide_index=True,
            key=unique_key
        )
    else:
        # Normal DataFrame'i g√∂ster
        st.data_editor(
            display_df,
            column_config=column_config,
            use_container_width=True,
            disabled=True,  # D√ºzenleme devre dƒ±≈üƒ±
            #hide_index=True,
            key=unique_key
        )

    # Excel √ßƒ±ktƒ±sƒ± olu≈ütur
    excel_buffer = BytesIO()
    try:
        with pd.ExcelWriter(excel_buffer, engine="openpyxl") as writer:
            df.to_excel(writer, index=False)

        # ƒ∞ndirme butonu
        st.download_button(
            label="‚¨á ƒ∞ndir (Excel)",
            data=excel_buffer.getvalue(),
            file_name=filename,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )
    except Exception as e:
        display_friendly_error(
            f"Excel olu≈üturma hatasƒ±: {str(e)}",
            "Veri formatƒ±nƒ± kontrol edin."
        )

    return excel_buffer


@handle_error
def show_grouped_summary(
    df: pd.DataFrame, 
    group_column: str, 
    target_columns: List[str], 
    filename: str, 
    title: Optional[str] = None, 
    style_func: Optional[Callable] = None,
    sticky_column: Optional[Union[str, int]] = None,
    page_size: int = 1000
) -> Optional[BytesIO]:
    """
    Gruplandƒ±rƒ±lmƒ±≈ü veri √∂zetini g√∂sterir ve Excel √ßƒ±ktƒ±sƒ± verir.
    
    Bu fonksiyon:
    1. Veriyi belirtilen s√ºtuna g√∂re gruplar
    2. Hedef s√ºtunlar i√ßin √∂zet istatistikler hesaplar
    3. Sonu√ßlarƒ± g√∂r√ºnt√ºler
    4. Excel √ßƒ±ktƒ±sƒ± olu≈üturur
    
    Parameters:
        df (DataFrame): ƒ∞≈ülenecek veri √ßer√ßevesi
        group_column (str): Gruplama yapƒ±lacak s√ºtun
        target_columns (List[str]): √ñzetlenecek s√ºtunlar
        filename (str): ƒ∞ndirme i√ßin dosya adƒ±
        title (str, optional): G√∂r√ºnt√ºleme ba≈ülƒ±ƒüƒ±
        style_func (Callable, optional): Uygulanacak stil fonksiyonu
        sticky_column (Union[str, int], optional): Sabit kalacak s√ºtun
        page_size (int): Sayfa ba≈üƒ±na satƒ±r sayƒ±sƒ±
        
    Returns:
        Optional[BytesIO]: Excel dosyasƒ± buffer'ƒ± veya None
        
    Hata durumunda:
    - Hata loglanƒ±r
    - Kullanƒ±cƒ±ya hata mesajƒ± g√∂sterilir
    - None d√∂nd√ºr√ºl√ºr
    
    √ñrnek:
        >>> df = pd.DataFrame({
        ...     "Kategori": ["A", "A", "B"],
        ...     "B√ºt√ße": [1000, 2000, 3000]
        ... })
        >>> buffer = show_grouped_summary(
        ...     df,
        ...     group_column="Kategori",
        ...     target_columns=["B√ºt√ße"],
        ...     filename="ozet.xlsx"
        ... )
    """
    # Ger√ßekten var olan kolonlarƒ± filtrele
    existing_columns = [col for col in target_columns if col in df.columns]

    if group_column in df.columns and existing_columns:
        if title:
            st.markdown(title)

        # T√ºm sayƒ±sal s√ºtunlarƒ± topla
        numeric_columns = [col for col in existing_columns if pd.api.types.is_numeric_dtype(df[col])]
        grouped_df = df.groupby(group_column)[numeric_columns].sum().reset_index()
        
        return show_filtered_data(
            grouped_df, 
            filename=filename, 
            style_func=style_func,
            sticky_column=sticky_column,
            page_size=page_size
        )
    else:
        display_friendly_error(
            f"'{group_column}' bazƒ±nda √∂zet olu≈üturulamadƒ±", 
            "Gerekli s√ºtunlar eksik olabilir."
        )
        return None


@handle_error
def calculate_group_totals(
    df: pd.DataFrame, 
    group_column: str, 
    selected_months: List[str], 
    metrics: List[str]
) -> pd.DataFrame:
    """
    Grup toplamlarƒ±nƒ± hesaplar.
    
    Bu fonksiyon:
    1. Veriyi belirtilen s√ºtuna g√∂re gruplar
    2. Se√ßili aylar i√ßin metrikleri hesaplar
    3. Toplamlarƒ± hesaplar
    4. Sonu√ßlarƒ± DataFrame olarak d√∂nd√ºr√ºr
    
    Parameters:
        df (DataFrame): ƒ∞≈ülenecek veri √ßer√ßevesi
        group_column (str): Gruplama yapƒ±lacak s√ºtun
        selected_months (List[str]): ƒ∞≈ülenecek aylar
        metrics (List[str]): Hesaplanacak metrikler
        
    Returns:
        DataFrame: Hesaplanmƒ±≈ü toplamlar
        
    Hata durumunda:
    - Hata loglanƒ±r
    - Bo≈ü DataFrame d√∂nd√ºr√ºl√ºr
    
    √ñrnek:
        >>> df = pd.DataFrame({
        ...     "Kategori": ["A", "A", "B"],
        ...     "Ocak B√ºt√ße": [1000, 2000, 3000]
        ... })
        >>> totals = calculate_group_totals(
        ...     df,
        ...     group_column="Kategori",
        ...     selected_months=["Ocak"],
        ...     metrics=["B√ºt√ße"]
        ... )
    """
    # Toplanacak s√ºtunlarƒ± belirle
    columns_to_sum = []
    for month in selected_months:
        for metric in metrics:
            col_name = f"{month} {metric}"
            if col_name in df.columns:
                columns_to_sum.append(col_name)

    if not columns_to_sum:
        display_friendly_error(
            "Toplanacak s√ºtun bulunamadƒ±",
            "L√ºtfen ay ve metrik se√ßimlerinizi kontrol edin."
        )
        return pd.DataFrame()

    # Gruplandƒ±rƒ±lmƒ±≈ü toplamlarƒ± hesapla
    try:
        grouped_totals = df.groupby(group_column)[columns_to_sum].sum()

        # Her metrik i√ßin toplam s√ºtun olu≈ütur
        for metric in metrics:
            # S√ºtun adƒ±nƒ± "Ay [Metrik]" formatƒ±nda b√∂l ve tam e≈üle≈üme kontrol et
            metric_cols = [
                col for col in columns_to_sum
                if col.split(" ", 1)[-1] == metric
            ]

            # "BE Bakiye" metriƒüi i√ßin "K√ºm√ºle BE Bakiye" s√ºtununu da kontrol et
            if metric == "BE Bakiye" and not metric_cols:
                # K√ºm√ºle BE Bakiye s√ºtunu varsa ekle
                kumule_col = "K√ºm√ºle BE Bakiye"
                if kumule_col in df.columns:
                    # T√ºm s√ºtunlarƒ± i√ßeren yeni bir DataFrame olu≈ütur
                    if kumule_col not in grouped_totals.columns:
                        kumule_data = df.groupby(group_column)[kumule_col].sum()
                        # Ayrƒ± bir seri olarak ekle
                        grouped_totals[f"Toplam {metric}"] = kumule_data
                        continue

            # "BE-Fiili Fark Bakiye" metriƒüi i√ßin "K√ºm√ºle BE-Fiili Fark Bakiye" s√ºtununu da kontrol et
            if metric == "BE-Fiili Fark Bakiye" and not metric_cols:
                # K√ºm√ºle BE-Fiili Fark Bakiye s√ºtunu varsa ekle
                kumule_col = "K√ºm√ºle BE-Fiili Fark Bakiye"
                if kumule_col in df.columns:
                    # T√ºm s√ºtunlarƒ± i√ßeren yeni bir DataFrame olu≈ütur
                    if kumule_col not in grouped_totals.columns:
                        kumule_data = df.groupby(group_column)[kumule_col].sum()
                        # Ayrƒ± bir seri olarak ekle
                        grouped_totals[f"Toplam {metric}"] = kumule_data
                        continue

            if metric_cols:
                grouped_totals[f"Toplam {metric}"] = grouped_totals[metric_cols].sum(axis=1)

        return grouped_totals[[f"Toplam {metric}" for metric in metrics if f"Toplam {metric}" in grouped_totals.columns]]
    except Exception as e:
        display_friendly_error(
            f"Grup toplamlarƒ± hesaplanƒ±rken hata olu≈ütu: {str(e)}",
            "Veri ve grup s√ºtununu kontrol edin."
        )
        return pd.DataFrame()


@handle_error
def show_column_totals(
    df: pd.DataFrame, 
    filename: str = "sutun_toplamlari.xlsx", 
    title: Optional[str] = None
) -> BytesIO:
    """
    S√ºtun toplamlarƒ±nƒ± g√∂sterir ve Excel √ßƒ±ktƒ±sƒ± verir.
    
    Bu fonksiyon:
    1. Sayƒ±sal s√ºtunlarƒ±n toplamlarƒ±nƒ± hesaplar
    2. Sonu√ßlarƒ± g√∂r√ºnt√ºler
    3. Excel √ßƒ±ktƒ±sƒ± olu≈üturur
    
    Parameters:
        df (DataFrame): ƒ∞≈ülenecek veri √ßer√ßevesi
        filename (str): ƒ∞ndirme i√ßin dosya adƒ±
        title (str, optional): G√∂r√ºnt√ºleme ba≈ülƒ±ƒüƒ±
        
    Returns:
        BytesIO: Excel dosyasƒ± buffer'ƒ±
        
    Hata durumunda:
    - Hata loglanƒ±r
    - Kullanƒ±cƒ±ya hata mesajƒ± g√∂sterilir
    - Bo≈ü buffer d√∂nd√ºr√ºl√ºr
    
    √ñrnek:
        >>> df = pd.DataFrame({
        ...     "B√ºt√ße": [1000, 2000, 3000],
        ...     "Fiili": [900, 2100, 2900]
        ... })
        >>> buffer = show_column_totals(
        ...     df,
        ...     filename="toplamlar.xlsx"
        ... )
    """
    from config.constants import GENERAL_COLUMNS
    
    # Sayƒ±sal s√ºtunlarƒ± filtreleme
    numeric_columns = [
        col for col in df.columns
        if col not in GENERAL_COLUMNS and pd.api.types.is_numeric_dtype(df[col])
    ]
    
    if not numeric_columns:
        display_friendly_error(
            "Sayƒ±sal s√ºtun bulunamadƒ±",
            "Veri formatƒ±nƒ± kontrol edin."
        )
        # Bo≈ü bir DataFrame olu≈ütur
        totals_df = pd.DataFrame({"Bilgi": ["Sayƒ±sal s√ºtun bulunamadƒ±"]})
    else:
        totals_df = pd.DataFrame(df[numeric_columns].sum()).T
        totals_df.index = ["Toplam"]

    return show_filtered_data(
        totals_df,
        filename=filename,
        title=title or "**Sayƒ±sal S√ºtunlarƒ±n Toplamlarƒ±**"
    )

